<!DOCTYPE html>
<title></title>
<meta charset="utf-8">
<script src="js/d3.v3.min.js"></script>
<script src="js/underscore-min.js"></script>
<script src="js/queue.min.js"></script>
<script src="js/jquery.min.js"></script>
<script src="js/tipsy.js"></script>
<link href="css/tipsy.css" rel="stylesheet" type="text/css" />

<style>

body {
  background: #F4F4F4;
  font: 10px Arial;
}
svg {
   background: #fff;
}


.active {
  opacity: 1!important;
}
.link {
  fill:none;
  stroke-width: 1px;
  stroke:#000;
  opacity: 0;
}

.lobby circle {
  fill:#000;
  opacity: 0.9;
}

.knoten {
  opacity: 0.1;
}

.node {
  fill:#000;
  opacity: 0.9;
}

.arc {
  cursor: pointer;
}
.arc path {
  fill:#EEE;
  stroke:#FFF;
  stroke-width:1px;
}
.arc:hover path {
  fill:auto;
}
.arc text {
  fill:#4c4c4c;
}
.arc circle {
  opacity: 0.2;
  fill:#FFF;
}

#filter {
  width: 200px;
  position: absolute;
  left: 750px;
}

#filter div {
  padding:5px;
  background: #EEE;
  margin: 5px;
}
#filter div>* {
  width: 95%;
}


</style>
<body>
<div id="filter">
  <div>Filter</div>
  <div>
    <input name="suche" type="text" size="20" value="Suche: Partei, Politiker, Lobbyist">
  </div>
  <div>
    <select>
      <option value="volvo">Funktionen</option>
      <option value="saab">Alle</option>
      <option value="saab">Gast</option>
      <option value="mercedes">Mitarbeiter/innen</option>
      <option value="audi">Keine Angabe</option>
      <option value="audi">Sonstige</option>
    </select>
  </div>
</div>
<div id="chart"></div>
</body>
<script>

  var w = 950, h = 800, r = 100;
  var svg = d3.select("#chart").append("svg")
      .attr("width", w)
      .attr("height", h)

  var animation = false;

  
  var makeRat = function(params){

    params.startAngle += params.arcPadding;
    params.endAngle -= params.arcPadding;

    var makeSeats = function(data){
      var seats = [];
      d3.range(params.rows).forEach(function(z){
        
        var angleDiff = data.endAngle - data.startAngle - 2*params.padding;
        var radiusDiff = params.outerRadius-params.innerRadius;
        var r = params.innerRadius + params.margin + (z/params.rows) * radiusDiff;
        var numPerRow = Math.abs(Math.floor((angleDiff * r) / params.margin));
        
        d3.range(numPerRow).forEach(function(s){

          var angle =  params.padding + data.startAngle + ((s+0.5)/numPerRow) * angleDiff;
          var x = Math.sin(angle)*r ;
          var y = -Math.cos(angle)*r ;
          seats.push({x:x,y:y});
        });
      });
      data.seats = seats;
    }

    var assignSeats = function(seats,persons){
      //console.log(seats,persons)
      if(seats.length<persons.length){
        console.log("not enough seats", seats.length-persons.length, seats,persons);
      }
      var i = 0;
      persons.forEach(function(p){
        p.x = seats[i].x;
        p.y = seats[i].y;
        i++;
      });
    }
    
    var arc = d3.svg.arc()
        .innerRadius(params.innerRadius)
        .outerRadius(params.outerRadius)

    var pie = d3.layout.pie()
        .value(function(d,i) { return d.values.length+ params.fillup; })
        .sort(null)
        .startAngle(params.startAngle)
        .endAngle(params.endAngle)

    var pieData = pie(params.data);

    console.log(pieData)

    var container = params.svg.append("g").attr('class', params.name);

    var arcs = container.selectAll(".arc")
      .data(pieData)
        .enter().append("g")
          .attr("class", "arc")
          .attr("fill", "#FFF")
    
    arcs.append("path")
      .attr("d", arc)
      .attr("class", function(d){ return d.data.key })

    arcs.append("text")
      .attr("transform", function(d) {
          var c = arc.centroid(d),
              x = c[0],
              y = c[1],
              angle = Math.atan2(y,x)*180/Math.PI+90 + params.labelOrientation,
              // pythagorean theorem for hypotenuse
              h = Math.sqrt(x*x + y*y);
          return "translate(" + (x/h * params.labelRadius) +  ',' +
             (y/h * params.labelRadius) +  ") rotate("+ angle +")"; 
      })
      .attr("dy", ".35em")
      .attr("text-anchor", "middle")
      .text(function(d, i) { return d.data.key; });

    arcs.each(function(d,i){
      makeSeats(d);
      assignSeats(d.seats,d.data.values);

      d3.select(this).append("g")
        .selectAll("circle")
        .data(d.data.values) 
          .enter()
            .append("circle")
            .attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; })
            .attr("r", 5)
            .attr("fill", function(d){ return params.fill(d.sort); })
    });

    // pieData.forEach(function(d){
    //   makeSeats(d);
    //   assignSeats(d.seats,d.data.values);

    //   container
    //     .append("g")
    //     .attr("class","seats")
    //     .selectAll("circle")
    //     .data(d.data.values)
    //       .enter()
    //         .append("circle")
    //         .attr("cx", 0)
    //         .attr("cy", 0)
    //         .attr("r", 1)
    //         .attr("fill", "#FFF")      
    //         // .on("mouseover", function(d1) { 
    //         //   d1.badges = d3.selectAll(".node").filter(function(d2){ return d1.id == d2.badgegeber_id })
    //         //     //.attr("r",7)
    //         //     .classed("active",true)

    //         //   d1.badges.forEach(function(d){
    //         //     $(d).tipsy("show")
    //         //   })
              

    //         //   d3.select(this).classed("active",true)
    //         // })
    //         // .on("mouseout", function(d1) { 
    //         //   d1.badges.attr("r",5).classed("active",false)

    //         //   d1.badges.forEach(function(d){
    //         //     $(d).tipsy("hide")
    //         //   })
    //         //   d3.select(this).classed("active",false)
    //         // });
    // });

    var seats = container.selectAll("circle")

    if(animation){
      seats
        .transition()
        .duration(function(d, i) { return i / badges.size() * 2000; })
       // .ease("elastic", 1, 0.8)
        .attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; })
        .attr("r", 5)
        .attr("fill", function(d){ return params.fill(d.sort); })

      arcs
        .transition()
        .delay(2000)
        .duration(function(d, i) { return i / arcs.size() * 1000; })
        .attr("fill", function(d){ return params.fill(d.data.key); })

    } else {
      seats
        .attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; })
        .attr("r", 5)
        .attr("fill", function(d){ return params.fill(d.sort); })

      arcs
        .attr("fill", function(d){ return params.fill(d.data.key); })

    }

    // $(".rat circle").tipsy({ 
    //     fade: false,
    //     gravity: 'w', 
    //     html: true, 
    //     title: function() {
    //       var d = this.__data__;
    //       return d.vorname + " " + d.nachname; 
    //     }
    //   });

    return {
      arc:arc,
      arcs:arcs,
      pieData:pieData
    }

  }

  queue()
    .defer(d3.csv, 'data/politiker.csv')
    .defer(d3.csv, 'data/badges.csv')
    .await(ready)

  function ready (error,politiker,badges) {
    var fill = d3.scale.category10();
  
    politiker.forEach(function(d){
      d.sort = d.partei.slice(0,3).toUpperCase();
      d.badges = badges.filter(function(badge){ return d.id == badge.badgegeber_id; });
    });

    badges.forEach(function(d){
      if(d.deklarierte_funktion == 0.0){
        d.deklarierte_funktion = "keine Angabe";
      }
      d.politiker = politiker.filter(function(pol){ return pol.id == d.badgegeber_id; })[0];
    });

    

    console.log(politiker[0],badges[0]);

    var nationalrat = d3.nest()
      .key(function(d) { return d.sort; })
      .entries(politiker.filter(function(d){ return d.rat == "NR" }));

    nationalrat = nationalrat.filter(function(d){ return d.values.length>1 });
    nationalrat.sort(function(a,b){
      return b.values.length - a.values.length;
    })

    var standerat = d3.nest()
      .key(function(d) { return d.sort; })
      .entries(politiker.filter(function(d){ return d.rat == "SR" }));

    standerat = standerat.filter(function(d){ return d.values.length>1 });
    
    standeratSort = [];
    nationalrat.forEach(function(d1){
      var ok = standerat.filter(function(d2){ return d1.key == d2.key});
      if(ok.length != 0){
        standeratSort.push(ok[0]);
      }
    });
    standerat = standeratSort;
    //standeratSort.reverse();


    var centerPos = {left:w/2 - 100,top:h/2};
    var circleSvg = svg.append("g")
        .attr("transform", "translate(" + centerPos.left + "," + centerPos.top  + ")")
        .attr("class","rat")
    
    var nationalratPie = makeRat({
      name: "nationalrat",
      innerRadius: 250,
      outerRadius: 330,
      labelRadius: 345,
      labelOrientation: 180,
      arcPadding:0.05,
      startAngle: Math.PI*0.5,
      endAngle: Math.PI*1.5,
      margin: 13,
      padding: 0.009,
      rows: 6,
      data: nationalrat,
      fill: fill,
      svg: circleSvg,
      fillup:9
    });

    var standeratPie = makeRat({
      name: "standerat",
      innerRadius: 250,
      outerRadius: 280,
      labelRadius: 295,
      labelOrientation: 0,
      startAngle: -Math.PI/2,
      endAngle: Math.PI/2,

      arcPadding:0.05,
      margin: 13,
      padding: 0.009,
      rows: 2,
      data: standeratSort,
      fill: fill,
      svg: circleSvg,
      fillup:0
    });

    // wandelhalle

    

    // var links = [];
    // funktionen.forEach(function(funktion){
    //   var last;
    //   funktion.values.forEach(function(a){
    //     funktion.values.forEach(function(b){
    //       if(a!=b){
    //         var link = { source: a, target: b};
    //         links.push(link);
    //       }
    //     });
    //   });
    // });

    
    var funktionen = d3.nest()
      .key(function(d) { return d.deklarierte_funktion.slice(0,5); })
      .entries(badges);

    var nodes = [];
    var andere = {
      key: "andere",
      values: []
    };
    nodes.push(andere);

    funktionen.forEach(function(d){
      d.radius = d.values.length+10;
      if (d.values.length>1) {
        nodes.push(d);
      } else {
        andere.values.push(d.values[0]);
      }
    });
    andere.radius = andere.values.length+10;

    var force = d3.layout.force()
        .nodes(nodes)
        .size([w, h])
        //.gravity(0.1)
        .charge(function(d,i){ 
          return -1*d.radius/10;
        })
        .friction(0.9)
        .start();

    var lobby = svg.append("g")
      .attr("transform", "translate(0," + h/1.2  + ")")
      .attr("class", "lobby")

    var node = lobby
      .selectAll(".node")
        .data(nodes)
      .enter().append("circle")
        .attr("r", 0)
        .style("fill", function(d, i) { 
            return fill(d.key);
        })

    node
      .transition()
      //.delay(function(d, i) { return i / d.radius * 2000; })
      .duration(1000)
     // .attr("r", function(d){ return d.radius; })

    function collide(node) {
      var r = node.radius + 16,
          nx1 = node.x - r,
          nx2 = node.x + r,
          ny1 = node.y - r,
          ny2 = node.y + r;
      return function(quad, x1, y1, x2, y2) {
        if (quad.point && (quad.point !== node)) {
          var x = node.x - quad.point.x,
              y = node.y - quad.point.y,
              l = Math.sqrt(x * x + y * y),
              r = node.radius + quad.point.radius;
          if (l < r) {
            l = (l - r) / l * .5;
            node.x -= x *= l;
            node.y -= y *= l;
            quad.point.x += x;
            quad.point.y += y;
          }
        }
        return x1 > nx2
            || x2 < nx1
            || y1 > ny2
            || y2 < ny1;
      };
    }
    
    force.on("tick", function(e) {

      nodes.forEach(function(d){
        d.x = d.x + (w/2 - d.x) * (0.1 + 0.02) * e.alpha;
        d.y = d.y + (h/2 - d.y) * (0.1 + 0.02) * e.alpha;
      })

      var q = d3.geom.quadtree(nodes),
          i = 0,
          n = nodes.length;

      while (++i < n) {
        q.visit(collide(nodes[i]));
      }
      

      node.attr("cx", function(d) { return d.x; })
          .attr("cy", function(d) { return d.y; });
    });

    
    var funktionen = d3.nest()
      .key(function(d) { return d.deklarierte_funktion.slice(0,5); })
      .entries(badges);

    var strength = d3.scale.sqrt()
      .domain([1, d3.max(funktionen, function(d){ return d.values.length })])
      .range([0.8, 0.2])

    var links = [];
    var nodes = [];

    var andere = { knoten: true, name: "andere", r:0.18};
    nodes.push(andere); 

    funktionen.forEach(function(funktion){
      if(funktion.values.length>1){
        var s = strength(funktion.values.length);
        var knoten = {
          r: s,
          knoten: true,
          name: funktion.values[0].deklarierte_funktion
        };
        nodes.push(knoten);

        funktion.values.forEach(function(target){
          nodes.push(target);

          var link = { source: knoten, target: target, strength:s};
          links.push(link);
        });
      } else {
        var target = funktion.values[0];
        var link = { source: andere, target: target, strength: 0.2};
        links.push(link);
        nodes.push(target);
      }
    })

    console.log(links)

    var force = d3.layout.force()
        .nodes(nodes)
        .links(links)
        .size([w, h])
        .linkDistance(function(d){
          //return 1/d.strength * 5;
          return 5;
        })
        .linkStrength(function(d){
          return d.strength;
        })
        .charge(-10)
        .start();

    var safety = 0;
    while(force.alpha() > 0.05) { 
        force.tick();
        if(safety++ > 500) {
          break;
        }
    }

    var lobby = svg.append("g")
      .attr("transform", "translate(0," + h/1.2  + ")")
      .attr("class", "lobby")

    var link = lobby.selectAll(".link")
          .data(links)
        .enter().append("line")
          .attr("class", "link")
          //.style("stroke-width", function(d) { return Math.sqrt(d.value); });

    var node = lobby
      .selectAll(".node")
        .data(nodes)
      .enter().append("circle")
        .attr("class", function(d, i) { 
          if (d.knoten) return "knoten";
          else return "node";
        })
        .attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; })
        .attr("r", function(d, i) { 
          if (d.knoten) return 1/d.r* 15;
          else return 5;
        })
        .style("fill", function(d, i) { 
          if (!d.knoten) {
            return fill(d.politiker.partei);
          }
        })
        //.style("stroke", function(d, i) { return d3.rgb(fill(i & 3)).darker(2); })
        .call(force.drag)
        .on("mousedown", function(d) { 
          console.log(d);
          d3.event.stopPropagation();
        })
        .on("mouseover", function(d1) { 
          d1.politiker = d3.selectAll(".rat circle").filter(function(d2){ return d2.id == d1.badgegeber_id })
            //.attr("r",7)
            .classed("active",true)

          d3.select(this).classed("active",true)

        })
        .on("mouseout", function(d1) { 
          d1.politiker
            .attr("r",5)
            .classed("active",false)

          d3.select(this).classed("active",false)
        })

    
    force.on("tick", function() {
        link.attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });

        node.attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; });
    });
    



    // d3.select("body")
    //    .on("mousedown", mousedown);
    // function mousedown() {
    //   politiker.forEach(function(o, i) {
    //     o.x += (Math.random() - .5) * 40;
    //     o.y += (Math.random() - .5) * 40;
    //   });
    //   force.resume();
    // }


  }
    

</script>
